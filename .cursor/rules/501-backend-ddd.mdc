---
description: 
globs: 
alwaysApply: false
---
---
description: バックエンドのドメイン駆動設計（DDD）プラクティス
globs: ["backend/**/*.{kt,java}"]
tags: ["backend", "domain", "ddd", "architecture"]
priority: 501
version: 1.0.0
---

# バックエンドのドメイン駆動設計（DDD）プラクティス

## アーキテクチャ概要

Xクローンバックエンドは、ドメイン駆動設計（DDD）の原則に基づいており、以下の層から構成されています：

```
backend/src/main/kotlin/com/example/xclone/
├── domain/             # ドメイン層：ビジネスルールとロジック
│   ├── user/           # ユーザードメイン
│   ├── post/           # 投稿ドメイン
│   ├── timeline/       # タイムラインドメイン
│   ├── follow/         # フォロー関係ドメイン
│   └── notification/   # 通知ドメイン
├── application/        # アプリケーション層：ユースケース実装
├── infrastructure/     # インフラストラクチャ層：外部システム連携
└── interfaces/         # インターフェース層：API・UIなど
```

## ドメイン層の構造

各ドメイン（バウンデッドコンテキスト）は以下の要素で構成されます：

```
domain/user/
├── model/              # エンティティ・値オブジェクト
│   ├── User.kt         # ユーザーエンティティ
│   ├── Username.kt     # ユーザー名値オブジェクト
│   └── Email.kt        # メール値オブジェクト
├── event/              # ドメインイベント
│   └── UserEvents.kt   # ユーザー関連イベント
├── exception/          # ドメイン固有の例外
│   └── UserExceptions.kt
├── repository/         # リポジトリインターフェース
│   └── UserRepository.kt
└── service/           # ドメインサービス
    └── UserService.kt
```

## エンティティと値オブジェクト

### エンティティ

- 識別子（ID）を持ち、ライフサイクルを通じて同一性が保たれるオブジェクト
- 不変条件（invariants）を自身で検証・維持する
- 副作用のない純粋な振る舞いを持つ
- 外部からの変更は限定的なファクトリメソッドやコマンドメソッドを通じて行う

```kotlin
package com.example.xclone.domain.user.model

data class User private constructor(
    val id: UUID,
    val username: Username,
    val displayName: String,
    val email: Email,
    val passwordHash: String,
    val bio: String?,
    val profileImageUrl: String?,
    val createdAt: LocalDateTime,
    val updatedAt: LocalDateTime
) {
    // ファクトリメソッド
    companion object {
        fun create(
            id: UUID,
            username: Username,
            displayName: String,
            email: Email,
            passwordHash: String
        ): User {
            val now = LocalDateTime.now()
            return User(
                id = id,
                username = username,
                displayName = displayName,
                email = email,
                passwordHash = passwordHash,
                bio = null,
                profileImageUrl = null,
                createdAt = now,
                updatedAt = now
            )
        }
    }
    
    // コマンドメソッド
    fun updateProfile(displayName: String, bio: String?, profileImageUrl: String?): User {
        return this.copy(
            displayName = displayName,
            bio = bio,
            profileImageUrl = profileImageUrl,
            updatedAt = LocalDateTime.now()
        )
    }
    
    // ビジネスルール
    fun canFollow(otherUser: User): Boolean {
        return this.id != otherUser.id
    }
}
```

### 値オブジェクト

- 属性のみで識別され、等価性で比較される
- 不変（Immutable）であり、生成後に変更されない
- ドメインの概念を表現し、自己検証ロジックを含む

```kotlin
package com.example.xclone.domain.user.model

data class Username private constructor(val value: String) {
    companion object {
        private val PATTERN = Regex("^[a-zA-Z0-9_]{3,15}$")
        
        fun of(value: String): Username {
            require(value.matches(PATTERN)) {
                "ユーザー名は英数字とアンダースコアのみで、3〜15文字の長さにする必要があります"
            }
            return Username(value.lowercase())
        }
    }
    
    override fun toString(): String = value
}
```

## 集約（Aggregate）

- 集約は相互に関連するエンティティと値オブジェクトのクラスター
- 各集約は単一の集約ルート（エンティティ）を持つ
- 集約ルートを通じてのみ集約内のオブジェクトにアクセスする
- トランザクション境界と一致させる

```
// Post集約の例
Post (集約ルート)
├── PostId (値オブジェクト)
├── PostContent (値オブジェクト)
├── PostMedia (エンティティ)
└── PostLike (エンティティ)
```

## リポジトリ

- 各集約ルートに対して1つのリポジトリを定義する
- リポジトリはドメイン層でインターフェースを定義し、インフラストラクチャ層で実装する
- 集約全体の永続化と再構築を担当する

```kotlin
package com.example.xclone.domain.post.repository

interface PostRepository {
    fun findById(id: UUID): Post?
    fun findByUserId(userId: UUID, pageable: Pageable): Page<Post>
    fun save(post: Post): Post
    fun delete(post: Post)
}
```

## ドメインサービス

- 単一のエンティティに属さないドメインロジックをカプセル化する
- 特定のユースケースに依存しない汎用的なドメインロジックのみを含める
- ステートレスであるべき

```kotlin
package com.example.xclone.domain.timeline.service

class TimelineService(
    private val postRepository: PostRepository,
    private val followRepository: FollowRepository
) {
    fun generateTimelineForUser(userId: UUID, pageable: Pageable): Page<Post> {
        val followingUserIds = followRepository.findFollowingByUserId(userId)
            .map { it.followedId }
        
        return postRepository.findByUserIdIn(followingUserIds + userId, pageable)
    }
}
```

## ドメインイベント

- ドメイン内の重要な変更を表現するイベントを定義する
- イベントは不変（Immutable）で過去形の名前を持つ
- 集約ルートからイベントを発行し、イベントハンドラーで処理する

```kotlin
package com.example.xclone.domain.post.event

sealed class PostEvent {
    data class PostCreated(
        val postId: UUID,
        val userId: UUID,
        val content: String,
        val createdAt: LocalDateTime
    ) : PostEvent()
    
    data class PostLiked(
        val postId: UUID,
        val userId: UUID,
        val likedAt: LocalDateTime
    ) : PostEvent()
}
```

## 境界づけられたコンテキスト（Bounded Context）

Xクローンアプリケーションは以下の主要なバウンデッドコンテキストで構成されています：

- **ユーザーコンテキスト**: ユーザー登録、認証、プロファイル管理
- **投稿コンテキスト**: 投稿の作成、表示、いいね、リツイート
- **タイムラインコンテキスト**: ユーザーフィードの生成と表示
- **フォローコンテキスト**: フォロー/フォロワー関係の管理
- **通知コンテキスト**: システム通知とユーザーアクション通知
- **検索コンテキスト**: ユーザーや投稿の検索機能

各コンテキスト間の連携は、コンテキストマップに基づいて以下のパターンを使用します：

- **共有カーネル**: 複数のコンテキストで共有されるドメインモデル
- **顧客/サプライヤー**: 片方が他方のニーズに合わせる関係
- **コンフォーミスト**: 変更の力がないコンテキストが他に従う関係
- **腐敗防止層**: 外部システムとの連携に使用する変換層

## UUIDの最適化

UUIDを主キーとして使用する際は、時系列でのインデックス効率を向上させるため、以下のUUID最適化を適用します：

- UUIDのタイムスタンプビットをスワップし、時系列順にソートされるようにする
- アプリケーション層でUUID⇔バイナリ変換を処理する

```kotlin
package com.example.xclone.domain.common

import java.nio.ByteBuffer
import java.util.UUID

object TimeBasedUUID {
    fun generate(): UUID {
        val uuid = UUID.randomUUID()
        return optimizeUUID(uuid)
    }
    
    fun optimizeUUID(uuid: UUID): UUID {
        val buffer = ByteBuffer.wrap(ByteArray(16))
        buffer.putLong(System.currentTimeMillis())
        buffer.putLong(uuid.getLeastSignificantBits())
        buffer.flip()
        
        return new UUID(buffer.getLong(), buffer.getLong())
    }
    
    fun toBytes(uuid: UUID): ByteArray {
        val buffer = ByteBuffer.wrap(ByteArray(16))
        buffer.putLong(uuid.getMostSignificantBits())
        buffer.putLong(uuid.getLeastSignificantBits())
        return buffer.array()
    }
    
    fun fromBytes(bytes: ByteArray): UUID {
        val buffer = ByteBuffer.wrap(bytes)
        val high = buffer.getLong()
        val low = buffer.getLong()
        return UUID(high, low)
    }
}
```

## ドメイン固有言語（DSL）の活用

KotlinのDSL機能を活用して、より表現力豊かなドメインモデルを構築することを推奨します：

```kotlin
// Post作成のためのDSL
class PostBuilder {
    var content: String = ""
    var mediaUrls: MutableList<String> = mutableListOf()
    
    fun build(userId: UUID): Post {
        require(content.isNotBlank()) { "投稿内容は空にできません" }
        
        return Post.create(
            id = TimeBasedUUID.generate(),
            userId = userId,
            content = content,
            mediaUrls = mediaUrls.toList()
        )
    }
}

fun createPost(userId: UUID, block: PostBuilder.() -> Unit): Post {
    val builder = PostBuilder()
    builder.block()
    return builder.build(userId)
}

// 使用例
val post = createPost(userId) {
    content = "Hello, world!"
    mediaUrls.add("https://example.com/image.jpg")
}
``` 