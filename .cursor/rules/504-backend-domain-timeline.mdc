---
description: タイムラインドメインの実装ガイドライン
globs: ["backend/**/domain/timeline/**/*.{kt,java}"]
tags: ["domain", "timeline", "backend", "ddd"]
priority: 504
version: 1.0.0
---

# タイムラインドメイン実装ガイドライン

## ドメイン概要

タイムラインドメインはXクローンアプリケーションにおいて、ユーザーのフィードを生成・管理する責務を担います。このドメインは投稿ドメインとフォロードメインからのデータを集約し、パーソナライズされたタイムラインを構築します。

## 主要な概念

- **ホームタイムライン**: フォローしているユーザーの投稿を時系列順に表示するフィード
- **ユーザータイムライン**: 特定ユーザーの投稿のみを表示するフィード
- **トレンドタイムライン**: 人気のある投稿や話題のハッシュタグをベースにしたフィード
- **タイムラインエントリ**: タイムラインを構成する個々の投稿アイテム
- **タイムラインアルゴリズム**: タイムラインの並び順や表示内容を決定するロジック

## ドメインモデル

### Timeline 値オブジェクト

タイムラインはエンティティではなく、値オブジェクトとして実装します。これは常に再構築可能なものであり、永続性を持ちません。

```kotlin
package com.example.xclone.domain.timeline.model

import com.example.xclone.domain.post.model.Post
import java.util.UUID

data class Timeline(
    val userId: UUID,
    val type: TimelineType,
    val entries: List<TimelineEntry>,
    val cursor: TimelineCursor?
) {
    companion object {
        fun empty(userId: UUID, type: TimelineType): Timeline {
            return Timeline(
                userId = userId,
                type = type,
                entries = emptyList(),
                cursor = null
            )
        }
    }
    
    fun isEmpty(): Boolean = entries.isEmpty()
    
    fun size(): Int = entries.size
    
    fun merge(other: Timeline): Timeline {
        require(this.userId == other.userId && this.type == other.type) {
            "異なるタイプのタイムラインはマージできません"
        }
        
        val mergedEntries = (this.entries + other.entries)
            .distinctBy { it.postId }
            .sortedByDescending { it.timestamp }
        
        return Timeline(
            userId = this.userId,
            type = this.type,
            entries = mergedEntries,
            cursor = other.cursor ?: this.cursor
        )
    }
}
```

### TimelineEntry 値オブジェクト

```kotlin
data class TimelineEntry(
    val postId: UUID,
    val authorId: UUID,
    val timestamp: LocalDateTime,
    val entryType: TimelineEntryType,
    val score: Double = 1.0
) {
    companion object {
        fun fromPost(post: Post): TimelineEntry {
            return TimelineEntry(
                postId = post.id,
                authorId = post.userId,
                timestamp = post.createdAt,
                entryType = when {
                    post.isRetweet -> TimelineEntryType.RETWEET
                    post.isReply() -> TimelineEntryType.REPLY
                    post.isQuote() -> TimelineEntryType.QUOTE
                    else -> TimelineEntryType.ORIGINAL
                }
            )
        }
    }
}
```

### タイムラインの種類と構成要素

```kotlin
enum class TimelineType {
    HOME,       // ホームタイムライン（フォロー中のユーザー投稿）
    USER,       // ユーザータイムライン（特定ユーザーの投稿）
    TRENDING,   // トレンドタイムライン（人気の投稿）
    SEARCH      // 検索タイムライン（検索結果）
}

enum class TimelineEntryType {
    ORIGINAL,   // オリジナル投稿
    REPLY,      // リプライ
    RETWEET,    // リツイート
    QUOTE,      // 引用リツイート
    PROMOTED    // プロモーション投稿
}

data class TimelineCursor(
    val value: String,
    val expiry: LocalDateTime
) {
    fun isValid(): Boolean = LocalDateTime.now().isBefore(expiry)
}
```

## リポジトリ

タイムラインドメインでは、タイムラインそのものを永続化しないため、従来の意味でのリポジトリは存在しません。代わりに、タイムラインの構築に必要なデータを取得する「クエリサービス」を利用します。

```kotlin
package com.example.xclone.domain.timeline.repository

import com.example.xclone.domain.post.model.Post
import com.example.xclone.domain.timeline.model.TimelineCriteria
import java.util.UUID

interface TimelineQueryService {
    fun findPostsByFollowedUsers(
        userId: UUID,
        criteria: TimelineCriteria
    ): List<Post>
    
    fun findPostsByUser(
        targetUserId: UUID,
        criteria: TimelineCriteria
    ): List<Post>
    
    fun findTrendingPosts(
        criteria: TimelineCriteria
    ): List<Post>
    
    fun findPostsByHashtag(
        hashtag: String,
        criteria: TimelineCriteria
    ): List<Post>
}

data class TimelineCriteria(
    val limit: Int,
    val cursor: String? = null,
    val includeReplies: Boolean = true,
    val includeRetweets: Boolean = true,
    val maxAge: Duration? = null
)
```

## ドメインサービス

タイムラインの構築と最適化を担当するドメインサービスを実装します。

```kotlin
package com.example.xclone.domain.timeline.service

import com.example.xclone.domain.timeline.model.Timeline
import com.example.xclone.domain.timeline.model.TimelineType
import com.example.xclone.domain.timeline.model.TimelineCriteria
import com.example.xclone.domain.timeline.repository.TimelineQueryService
import com.example.xclone.domain.follow.repository.FollowRepository
import java.util.UUID

class TimelineService(
    private val timelineQueryService: TimelineQueryService,
    private val followRepository: FollowRepository,
    private val timelineAlgorithm: TimelineAlgorithm
) {
    /**
     * ユーザーのホームタイムラインを生成します
     */
    fun generateHomeTimeline(
        userId: UUID,
        criteria: TimelineCriteria
    ): Timeline {
        // フォロー中のユーザーの投稿を取得
        val posts = timelineQueryService.findPostsByFollowedUsers(userId, criteria)
        if (posts.isEmpty()) {
            return Timeline.empty(userId, TimelineType.HOME)
        }
        
        // タイムラインエントリに変換
        val entries = posts.map { TimelineEntry.fromPost(it) }
        
        // タイムラインアルゴリズムで並べ替え・フィルタリング
        val optimizedEntries = timelineAlgorithm.optimizeTimeline(
            entries = entries,
            userId = userId,
            timelineType = TimelineType.HOME
        )
        
        // カーソル生成
        val cursor = generateCursor(posts.lastOrNull())
        
        return Timeline(
            userId = userId,
            type = TimelineType.HOME,
            entries = optimizedEntries,
            cursor = cursor
        )
    }
    
    /**
     * ユーザープロファイルのタイムラインを生成します
     */
    fun generateUserTimeline(
        viewerId: UUID,
        targetUserId: UUID,
        criteria: TimelineCriteria
    ): Timeline {
        // 対象ユーザーの投稿を取得
        val posts = timelineQueryService.findPostsByUser(targetUserId, criteria)
        if (posts.isEmpty()) {
            return Timeline.empty(viewerId, TimelineType.USER)
        }
        
        // タイムラインエントリに変換
        val entries = posts.map { TimelineEntry.fromPost(it) }
        
        // ユーザータイムラインは通常時系列順のため、最適化は最小限
        val optimizedEntries = timelineAlgorithm.optimizeTimeline(
            entries = entries,
            userId = viewerId,
            timelineType = TimelineType.USER
        )
        
        // カーソル生成
        val cursor = generateCursor(posts.lastOrNull())
        
        return Timeline(
            userId = viewerId,
            type = TimelineType.USER,
            entries = optimizedEntries,
            cursor = cursor
        )
    }
    
    /**
     * トレンドタイムラインを生成します
     */
    fun generateTrendingTimeline(
        userId: UUID,
        criteria: TimelineCriteria
    ): Timeline {
        // 人気の投稿を取得
        val posts = timelineQueryService.findTrendingPosts(criteria)
        if (posts.isEmpty()) {
            return Timeline.empty(userId, TimelineType.TRENDING)
        }
        
        // タイムラインエントリに変換（トレンドはスコアに基づく）
        val entries = posts.mapIndexed { index, post ->
            val score = 1.0 - (index.toDouble() / posts.size)
            TimelineEntry.fromPost(post).copy(score = score)
        }
        
        // トレンドタイムラインは既にスコア順になっているため、最適化は最小限
        val optimizedEntries = timelineAlgorithm.optimizeTimeline(
            entries = entries,
            userId = userId,
            timelineType = TimelineType.TRENDING
        )
        
        // カーソル生成
        val cursor = generateCursor(posts.lastOrNull())
        
        return Timeline(
            userId = userId,
            type = TimelineType.TRENDING,
            entries = optimizedEntries,
            cursor = cursor
        )
    }
    
    private fun generateCursor(lastPost: Post?): TimelineCursor? {
        if (lastPost == null) return null
        
        val cursorValue = Base64.getEncoder().encodeToString(
            "${lastPost.id}-${lastPost.createdAt.toEpochSecond()}".toByteArray()
        )
        
        return TimelineCursor(
            value = cursorValue,
            expiry = LocalDateTime.now().plusHours(1)
        )
    }
}
```

## タイムラインアルゴリズム

タイムラインの並び順や表示内容を決定するアルゴリズムを実装します。

```kotlin
package com.example.xclone.domain.timeline.algorithm

import com.example.xclone.domain.timeline.model.TimelineEntry
import com.example.xclone.domain.timeline.model.TimelineType
import java.util.UUID

interface TimelineAlgorithm {
    fun optimizeTimeline(
        entries: List<TimelineEntry>,
        userId: UUID,
        timelineType: TimelineType
    ): List<TimelineEntry>
}

class DefaultTimelineAlgorithm : TimelineAlgorithm {
    override fun optimizeTimeline(
        entries: List<TimelineEntry>,
        userId: UUID,
        timelineType: TimelineType
    ): List<TimelineEntry> {
        return when (timelineType) {
            TimelineType.HOME -> optimizeHomeTimeline(entries, userId)
            TimelineType.USER -> optimizeUserTimeline(entries)
            TimelineType.TRENDING -> optimizeTrendingTimeline(entries)
            TimelineType.SEARCH -> entries.sortedByDescending { it.timestamp }
        }
    }
    
    private fun optimizeHomeTimeline(
        entries: List<TimelineEntry>,
        userId: UUID
    ): List<TimelineEntry> {
        // ホームタイムラインは基本的に時系列順だが、
        // 人気のある投稿や関連性の高い投稿を優先的に表示することもある
        return entries
            .sortedByDescending { it.timestamp }
    }
    
    private fun optimizeUserTimeline(entries: List<TimelineEntry>): List<TimelineEntry> {
        // ユーザータイムラインは単純に時系列順
        return entries
            .sortedByDescending { it.timestamp }
    }
    
    private fun optimizeTrendingTimeline(entries: List<TimelineEntry>): List<TimelineEntry> {
        // トレンドタイムラインはスコア順
        return entries
            .sortedByDescending { it.score }
    }
}

class PersonalizedTimelineAlgorithm(
    private val userInteractionRepository: UserInteractionRepository
) : TimelineAlgorithm {
    override fun optimizeTimeline(
        entries: List<TimelineEntry>,
        userId: UUID,
        timelineType: TimelineType
    ): List<TimelineEntry> {
        if (timelineType != TimelineType.HOME) {
            // パーソナライズはホームタイムラインのみに適用
            return DefaultTimelineAlgorithm().optimizeTimeline(entries, userId, timelineType)
        }
        
        // ユーザーのインタラクション履歴からスコアを計算
        val userInteractions = userInteractionRepository.findByUserId(userId)
        val authorScores = calculateAuthorScores(userInteractions)
        
        // 各エントリにパーソナライズドスコアを適用
        val scoredEntries = entries.map { entry ->
            val interactionScore = authorScores[entry.authorId] ?: 1.0
            val timeScore = calculateTimeScore(entry.timestamp)
            val totalScore = interactionScore * timeScore
            
            entry.copy(score = totalScore)
        }
        
        // スコアでソート
        return scoredEntries.sortedByDescending { it.score }
    }
    
    private fun calculateAuthorScores(interactions: List<UserInteraction>): Map<UUID, Double> {
        // 著者ごとのインタラクションスコアを計算
        return interactions
            .groupBy { it.targetUserId }
            .mapValues { (_, interactions) ->
                interactions.sumByDouble { interaction ->
                    when (interaction.type) {
                        InteractionType.LIKE -> 1.0
                        InteractionType.RETWEET -> 2.0
                        InteractionType.REPLY -> 3.0
                        InteractionType.PROFILE_VIEW -> 0.5
                    }
                }.coerceAtLeast(1.0)
            }
    }
    
    private fun calculateTimeScore(timestamp: LocalDateTime): Double {
        // 最近の投稿ほど高スコア
        val ageHours = ChronoUnit.HOURS.between(timestamp, LocalDateTime.now()).toDouble()
        return Math.exp(-0.05 * ageHours) // 半減期約14時間の指数関数
    }
}
```

## タイムラインのキャッシュ戦略

タイムラインの生成は計算コストが高いため、効率的なキャッシュ戦略が重要です。

```kotlin
package com.example.xclone.domain.timeline.cache

import com.example.xclone.domain.timeline.model.Timeline
import com.example.xclone.domain.timeline.model.TimelineType
import java.util.UUID

interface TimelineCache {
    fun getTimeline(userId: UUID, type: TimelineType): Timeline?
    fun saveTimeline(timeline: Timeline, ttl: Duration)
    fun invalidateTimeline(userId: UUID, type: TimelineType)
    fun invalidateUserTimelines(targetUserId: UUID)
}

class RedisTimelineCache(
    private val redisTemplate: RedisTemplate<String, Any>
) : TimelineCache {
    private val objectMapper = ObjectMapper()
    
    override fun getTimeline(userId: UUID, type: TimelineType): Timeline? {
        val key = generateKey(userId, type)
        val cachedValue = redisTemplate.opsForValue().get(key) as? String ?: return null
        
        return try {
            objectMapper.readValue(cachedValue, Timeline::class.java)
        } catch (e: Exception) {
            null
        }
    }
    
    override fun saveTimeline(timeline: Timeline, ttl: Duration) {
        val key = generateKey(timeline.userId, timeline.type)
        val value = objectMapper.writeValueAsString(timeline)
        
        redisTemplate.opsForValue().set(key, value, ttl)
    }
    
    override fun invalidateTimeline(userId: UUID, type: TimelineType) {
        val key = generateKey(userId, type)
        redisTemplate.delete(key)
    }
    
    override fun invalidateUserTimelines(targetUserId: UUID) {
        // 対象ユーザーの投稿が含まれる可能性のあるタイムラインを無効化
        // 実際の実装では、フォロワーリストを取得して各フォロワーのタイムラインを無効化する
        // ここでは簡略化のため省略
    }
    
    private fun generateKey(userId: UUID, type: TimelineType): String {
        return "timeline:${userId}:${type.name.lowercase()}"
    }
}
```

## イベントハンドラー

タイムラインは、投稿やフォロー関係の変更イベントを監視して、適切にキャッシュを無効化する必要があります。

```kotlin
package com.example.xclone.domain.timeline.event

import com.example.xclone.domain.post.event.PostEvent
import com.example.xclone.domain.follow.event.FollowEvent
import com.example.xclone.domain.timeline.cache.TimelineCache
import org.springframework.context.event.EventListener
import org.springframework.stereotype.Component

@Component
class TimelineEventHandler(
    private val timelineCache: TimelineCache
) {
    @EventListener
    fun handlePostCreated(event: PostEvent.PostCreated) {
        // 投稿者のユーザータイムラインを無効化
        timelineCache.invalidateTimeline(event.userId, TimelineType.USER)
        
        // フォロワーのホームタイムラインを無効化（実際の実装では非同期で処理）
        // フォロワーリストを取得して各フォロワーのタイムラインを無効化する
    }
    
    @EventListener
    fun handlePostLiked(event: PostEvent.PostLiked) {
        // いいねはタイムラインに直接影響しないため、キャッシュ無効化は不要
    }
    
    @EventListener
    fun handlePostDeleted(event: PostEvent.PostDeleted) {
        // 投稿者のユーザータイムラインを無効化
        timelineCache.invalidateTimeline(event.userId, TimelineType.USER)
        
        // フォロワーのホームタイムラインを無効化（実際の実装では非同期で処理）
    }
    
    @EventListener
    fun handleFollowCreated(event: FollowEvent.FollowCreated) {
        // フォローした側のホームタイムラインを無効化
        timelineCache.invalidateTimeline(event.followerId, TimelineType.HOME)
    }
    
    @EventListener
    fun handleFollowDeleted(event: FollowEvent.FollowDeleted) {
        // フォロー解除した側のホームタイムラインを無効化
        timelineCache.invalidateTimeline(event.followerId, TimelineType.HOME)
    }
}
```

## パフォーマンス考慮事項

1. タイムラインの生成はコストが高いため、キャッシュを効果的に活用する
2. ホームタイムラインは定期的なバックグラウンドジョブで事前に生成しておく
3. リアルタイム性が重要な場合はWebSocketやSSEを使用して更新を配信
4. ユーザー数が増えると複雑になるため、フォロワー数の多いユーザーには特別な処理を実装

## スケーラビリティ考慮事項

1. ユーザー数の増加に伴い、タイムライン生成の負荷が指数関数的に増大する可能性がある
2. フォロワー数の多いユーザー（セレブリティアカウント）には特別な最適化が必要
3. シャーディングを活用してユーザーグループごとにタイムライン処理を分散させる
4. 巨大なタイムラインはページネーションとカーソルベースのページングを活用する