---
description: フォロー関係ドメインの実装ガイドライン
globs: ["backend/**/domain/follow/**/*.{kt,java}"]
tags: ["domain", "follow", "backend", "ddd"]
priority: 505
version: 1.0.0
---

# フォロー関係ドメイン実装ガイドライン

## ドメイン概要

フォロードメインはXクローンアプリケーションにおいて、ユーザー間のフォロー/フォロワー関係を管理する責務を担います。このドメインは、ユーザーの社会的グラフを構築し、タイムラインドメインや通知ドメインと密接に連携します。

## 主要な概念

- **フォロー関係**: あるユーザーが別のユーザーをフォローする関係
- **フォロワー**: あるユーザーをフォローしているユーザー群
- **フォロー中**: あるユーザーがフォローしているユーザー群
- **ブロック関係**: あるユーザーが別のユーザーをブロックする関係
- **ミュート関係**: あるユーザーが別のユーザーをミュートする関係

## ドメインモデル

### Follow エンティティ

```kotlin
package com.example.xclone.domain.follow.model

import com.example.xclone.domain.common.TimeBasedUUID
import java.time.LocalDateTime
import java.util.UUID

data class Follow private constructor(
    val id: UUID,
    val followerId: UUID,
    val followedId: UUID,
    val createdAt: LocalDateTime
) {
    companion object {
        fun create(followerId: UUID, followedId: UUID): Follow {
            require(followerId != followedId) {
                "ユーザーは自分自身をフォローできません"
            }
            
            return Follow(
                id = TimeBasedUUID.generate(),
                followerId = followerId,
                followedId = followedId,
                createdAt = LocalDateTime.now()
            )
        }
    }
}
```

### Block エンティティ

```kotlin
package com.example.xclone.domain.follow.model

import com.example.xclone.domain.common.TimeBasedUUID
import java.time.LocalDateTime
import java.util.UUID

data class Block private constructor(
    val id: UUID,
    val blockerId: UUID,
    val blockedId: UUID,
    val createdAt: LocalDateTime
) {
    companion object {
        fun create(blockerId: UUID, blockedId: UUID): Block {
            require(blockerId != blockedId) {
                "ユーザーは自分自身をブロックできません"
            }
            
            return Block(
                id = TimeBasedUUID.generate(),
                blockerId = blockerId,
                blockedId = blockedId,
                createdAt = LocalDateTime.now()
            )
        }
    }
}
```

### Mute エンティティ

```kotlin
package com.example.xclone.domain.follow.model

import com.example.xclone.domain.common.TimeBasedUUID
import java.time.LocalDateTime
import java.util.UUID

data class Mute private constructor(
    val id: UUID,
    val muterId: UUID,
    val mutedId: UUID,
    val createdAt: LocalDateTime,
    val expiresAt: LocalDateTime?
) {
    companion object {
        fun create(
            muterId: UUID, 
            mutedId: UUID, 
            duration: java.time.Duration? = null
        ): Mute {
            require(muterId != mutedId) {
                "ユーザーは自分自身をミュートできません"
            }
            
            val now = LocalDateTime.now()
            
            return Mute(
                id = TimeBasedUUID.generate(),
                muterId = muterId,
                mutedId = mutedId,
                createdAt = now,
                expiresAt = duration?.let { now.plus(it) }
            )
        }
    }
    
    fun isExpired(): Boolean {
        return expiresAt?.let { LocalDateTime.now().isAfter(it) } ?: false
    }
    
    fun isActive(): Boolean = !isExpired()
}
```

## リポジトリ

```kotlin
package com.example.xclone.domain.follow.repository

import com.example.xclone.domain.follow.model.Follow
import java.util.UUID
import org.springframework.data.domain.Page
import org.springframework.data.domain.Pageable

interface FollowRepository {
    fun findById(id: UUID): Follow?
    fun findByFollowerIdAndFollowedId(followerId: UUID, followedId: UUID): Follow?
    fun existsByFollowerIdAndFollowedId(followerId: UUID, followedId: UUID): Boolean
    fun findFollowersByFollowedId(followedId: UUID, pageable: Pageable): Page<Follow>
    fun findFollowedByFollowerId(followerId: UUID, pageable: Pageable): Page<Follow>
    fun countFollowersByFollowedId(followedId: UUID): Long
    fun countFollowedByFollowerId(followerId: UUID): Long
    fun save(follow: Follow): Follow
    fun delete(follow: Follow)
}

interface BlockRepository {
    fun findById(id: UUID): Block?
    fun findByBlockerIdAndBlockedId(blockerId: UUID, blockedId: UUID): Block?
    fun existsByBlockerIdAndBlockedId(blockerId: UUID, blockedId: UUID): Boolean
    fun findByBlockerId(blockerId: UUID, pageable: Pageable): Page<Block>
    fun save(block: Block): Block
    fun delete(block: Block)
}

interface MuteRepository {
    fun findById(id: UUID): Mute?
    fun findByMuterIdAndMutedId(muterId: UUID, mutedId: UUID): Mute?
    fun existsByMuterIdAndMutedIdAndActive(muterId: UUID, mutedId: UUID, active: Boolean = true): Boolean
    fun findByMuterId(muterId: UUID, pageable: Pageable): Page<Mute>
    fun save(mute: Mute): Mute
    fun delete(mute: Mute)
}
```

## ドメインサービス

```kotlin
package com.example.xclone.domain.follow.service

import com.example.xclone.domain.follow.model.Follow
import com.example.xclone.domain.follow.model.Block
import com.example.xclone.domain.follow.model.Mute
import com.example.xclone.domain.follow.repository.FollowRepository
import com.example.xclone.domain.follow.repository.BlockRepository
import com.example.xclone.domain.follow.repository.MuteRepository
import com.example.xclone.domain.follow.exception.FollowException
import java.util.UUID
import org.springframework.data.domain.Page
import org.springframework.data.domain.Pageable

class FollowService(
    private val followRepository: FollowRepository,
    private val blockRepository: BlockRepository,
    private val muteRepository: MuteRepository
) {
    /**
     * ユーザーをフォローします
     */
    fun followUser(followerId: UUID, followedId: UUID): Follow {
        // 自分自身をフォローできないチェックはエンティティ側で行われる
        
        // 既にフォロー済みかチェック
        if (followRepository.existsByFollowerIdAndFollowedId(followerId, followedId)) {
            throw FollowException.AlreadyFollowingException("既にフォローしています")
        }
        
        // ブロック関係のチェック
        if (blockRepository.existsByBlockerIdAndBlockedId(followedId, followerId)) {
            throw FollowException.BlockedByUserException("このユーザーにブロックされています")
        }
        
        if (blockRepository.existsByBlockerIdAndBlockedId(followerId, followedId)) {
            throw FollowException.UserBlockedException("ブロックしているユーザーはフォローできません")
        }
        
        // フォロー関係の作成
        val follow = Follow.create(followerId, followedId)
        return followRepository.save(follow)
    }
    
    /**
     * フォローを解除します
     */
    fun unfollowUser(followerId: UUID, followedId: UUID) {
        val follow = followRepository.findByFollowerIdAndFollowedId(followerId, followedId)
            ?: throw FollowException.NotFollowingException("フォローしていません")
        
        followRepository.delete(follow)
    }
    
    /**
     * ユーザーをブロックします
     */
    fun blockUser(blockerId: UUID, blockedId: UUID): Block {
        // 既存のフォロー関係を削除
        followRepository.findByFollowerIdAndFollowedId(blockerId, blockedId)?.let {
            followRepository.delete(it)
        }
        
        followRepository.findByFollowerIdAndFollowedId(blockedId, blockerId)?.let {
            followRepository.delete(it)
        }
        
        // 既存のブロック関係をチェック
        blockRepository.findByBlockerIdAndBlockedId(blockerId, blockedId)?.let {
            return it // 既にブロック済み
        }
        
        // ブロック関係の作成
        val block = Block.create(blockerId, blockedId)
        return blockRepository.save(block)
    }
    
    /**
     * ブロックを解除します
     */
    fun unblockUser(blockerId: UUID, blockedId: UUID) {
        val block = blockRepository.findByBlockerIdAndBlockedId(blockerId, blockedId)
            ?: throw FollowException.NotBlockedException("ブロックしていません")
        
        blockRepository.delete(block)
    }
    
    /**
     * ユーザーをミュートします
     */
    fun muteUser(
        muterId: UUID, 
        mutedId: UUID, 
        duration: java.time.Duration? = null
    ): Mute {
        // 既存のミュート関係をチェック
        muteRepository.findByMuterIdAndMutedId(muterId, mutedId)?.let {
            if (it.isActive()) {
                return it // 既にミュート中
            }
            muteRepository.delete(it) // 期限切れのミュートは削除
        }
        
        // ミュート関係の作成
        val mute = Mute.create(muterId, mutedId, duration)
        return muteRepository.save(mute)
    }
    
    /**
     * ミュートを解除します
     */
    fun unmuteUser(muterId: UUID, mutedId: UUID) {
        val mute = muteRepository.findByMuterIdAndMutedId(muterId, mutedId)
            ?: throw FollowException.NotMutedException("ミュートしていません")
        
        muteRepository.delete(mute)
    }
    
    /**
     * フォロー関係を確認します
     */
    fun checkFollowStatus(followerId: UUID, followedId: UUID): FollowStatus {
        val isFollowing = followRepository.existsByFollowerIdAndFollowedId(followerId, followedId)
        val isFollowed = followRepository.existsByFollowerIdAndFollowedId(followedId, followerId)
        val isBlocked = blockRepository.existsByBlockerIdAndBlockedId(followerId, followedId)
        val isBlockedBy = blockRepository.existsByBlockerIdAndBlockedId(followedId, followerId)
        val isMuted = muteRepository.existsByMuterIdAndMutedIdAndActive(followerId, followedId)
        
        return FollowStatus(
            isFollowing = isFollowing,
            isFollowed = isFollowed,
            isBlocked = isBlocked,
            isBlockedBy = isBlockedBy,
            isMuted = isMuted
        )
    }
    
    /**
     * ユーザーのフォロワー数を取得します
     */
    fun getFollowersCount(userId: UUID): Long {
        return followRepository.countFollowersByFollowedId(userId)
    }
    
    /**
     * ユーザーのフォロー数を取得します
     */
    fun getFollowingCount(userId: UUID): Long {
        return followRepository.countFollowedByFollowerId(userId)
    }
    
    /**
     * ユーザーのフォロワーを取得します
     */
    fun getFollowers(userId: UUID, pageable: Pageable): Page<Follow> {
        return followRepository.findFollowersByFollowedId(userId, pageable)
    }
    
    /**
     * ユーザーがフォローしているユーザーを取得します
     */
    fun getFollowing(userId: UUID, pageable: Pageable): Page<Follow> {
        return followRepository.findFollowedByFollowerId(userId, pageable)
    }
}

data class FollowStatus(
    val isFollowing: Boolean,
    val isFollowed: Boolean,
    val isBlocked: Boolean,
    val isBlockedBy: Boolean,
    val isMuted: Boolean
)
```

## ドメインイベント

```kotlin
package com.example.xclone.domain.follow.event

sealed class FollowEvent {
    data class FollowCreated(
        val id: UUID,
        val followerId: UUID,
        val followedId: UUID,
        val createdAt: LocalDateTime
    ) : FollowEvent()
    
    data class FollowDeleted(
        val followerId: UUID,
        val followedId: UUID,
        val deletedAt: LocalDateTime
    ) : FollowEvent()
    
    data class BlockCreated(
        val id: UUID,
        val blockerId: UUID,
        val blockedId: UUID,
        val createdAt: LocalDateTime
    ) : FollowEvent()
    
    data class BlockDeleted(
        val blockerId: UUID,
        val blockedId: UUID,
        val deletedAt: LocalDateTime
    ) : FollowEvent()
    
    data class MuteCreated(
        val id: UUID,
        val muterId: UUID,
        val mutedId: UUID,
        val expiresAt: LocalDateTime?,
        val createdAt: LocalDateTime
    ) : FollowEvent()
    
    data class MuteDeleted(
        val muterId: UUID,
        val mutedId: UUID,
        val deletedAt: LocalDateTime
    ) : FollowEvent()
}
```

## 例外

```kotlin
package com.example.xclone.domain.follow.exception

sealed class FollowException(message: String) : RuntimeException(message) {
    class AlreadyFollowingException(message: String) : FollowException(message)
    class NotFollowingException(message: String) : FollowException(message)
    class BlockedByUserException(message: String) : FollowException(message)
    class UserBlockedException(message: String) : FollowException(message)
    class NotBlockedException(message: String) : FollowException(message)
    class NotMutedException(message: String) : FollowException(message)
    class SelfFollowException(message: String) : FollowException(message)
    class SelfBlockException(message: String) : FollowException(message)
    class SelfMuteException(message: String) : FollowException(message)
}
```

## ユースケース例

### ユーザーをフォローする

```kotlin
// アプリケーション層のユースケース
class FollowUserUseCase(
    private val followService: FollowService,
    private val userRepository: UserRepository,
    private val eventPublisher: ApplicationEventPublisher
) {
    fun execute(request: FollowUserRequest, currentUserId: UUID): FollowStatus {
        // ユーザーの存在確認
        val targetUser = userRepository.findById(request.targetUserId)
            ?: throw UserNotFoundException("ユーザーが見つかりません: ${request.targetUserId}")
        
        // フォロー処理
        val follow = followService.followUser(currentUserId, targetUser.id)
        
        // イベント発行
        eventPublisher.publishEvent(
            FollowEvent.FollowCreated(
                id = follow.id,
                followerId = follow.followerId,
                followedId = follow.followedId,
                createdAt = follow.createdAt
            )
        )
        
        // フォロー状態を返却
        return followService.checkFollowStatus(currentUserId, targetUser.id)
    }
}

data class FollowUserRequest(
    val targetUserId: UUID
)
```

## 主要なビジネスルール

1. ユーザーは自分自身をフォロー、ブロック、ミュートできない
2. ブロックされているユーザーはフォローできない
3. ユーザーをブロックすると、相互のフォロー関係は自動的に解除される
4. ミュートはオプションで期限を設定できる
5. ブロックしているユーザーはフォローできない
6. ユーザーがアカウントを削除すると、関連するすべてのフォロー関係も削除される

## 実装上の考慮事項

### パフォーマンス最適化

1. フォロワー数やフォロー数のカウントはキャッシュする
2. 有名人など、フォロワー数が非常に多いユーザーには特別な処理を実装する
3. フォロー関係のチェックは高速に行えるようにインデックスを適切に設定する

### セキュリティ考慮事項

1. プライベートアカウントのフォロー関係は承認プロセスを経る
2. ブロックしているユーザーからは自分の投稿や情報が見えないようにする
3. ミュートしているユーザーの投稿はタイムラインに表示しない

### スケーラビリティ

1. フォロー関係のデータは膨大になるため、シャーディングを検討する
2. フォロワー数が多いユーザーのフォロー関係の変更は、非同期で処理する
3. フォロワーリストの取得はページネーションを必ず実装する

### コンシステンシー

1. フォロー関係の削除は、関連するタイムラインキャッシュの無効化と同期する
2. フォロー、ブロック、ミュートの状態変更は、整合性を保つために適切なトランザクション管理を行う 