---
description: 
globs: 
alwaysApply: false
---
---
description: Apply security best practices and RESTful API design principles
globs: ["backend/**/*Security*", "backend/**/*Controller*", "backend/**/*Auth*", "frontend/**/*api*"]
tags: ["security", "api", "authentication", "authorization"]
priority: 4
version: 1.0.0
---

# Security and API Design

## Authentication & Authorization
- JWT-based authentication
- Role-based access control (RBAC)
- OAuth 2.0 / OpenID Connect standards
- Secure password storage with bcrypt

## API Security
- HTTPS for all communications
- CSRF protection for browser clients
- Rate limiting to prevent abuse
- Input validation for all parameters
- Content Security Policy (CSP)
- HTTP Security Headers
- CORS configuration

## RESTful API Design
- Follow REST principles for API design
- Use appropriate HTTP methods (GET, POST, PUT, DELETE)
- Return appropriate HTTP status codes
- Implement consistent error responses
- Version APIs with URL prefix
- Use plural nouns for resource collections
- Implement pagination for large collections
- Support filtering, sorting, and field selection

## API Request/Response Format
- Use JSON for request and response bodies
- Use camelCase for field names
- Use ISO 8601 format for dates and times
- Include pagination metadata for collection responses
- Implement consistent error responses

### Example API Endpoints

```
# User Resources
GET    /api/v1/users              # List users
POST   /api/v1/users              # Create user
GET    /api/v1/users/{id}         # Get user details
PUT    /api/v1/users/{id}         # Update user
DELETE /api/v1/users/{id}         # Delete user

# Post Resources
GET    /api/v1/posts              # List posts
POST   /api/v1/posts              # Create post
GET    /api/v1/posts/{id}         # Get post details
PUT    /api/v1/posts/{id}         # Update post
DELETE /api/v1/posts/{id}         # Delete post
GET    /api/v1/posts/{id}/likes   # Get post likes
POST   /api/v1/posts/{id}/likes   # Like post
DELETE /api/v1/posts/{id}/likes   # Unlike post

# Timeline Resources
GET    /api/v1/timeline/home      # Get home timeline
GET    /api/v1/timeline/user/{id} # Get user timeline
```

## JWT Implementation
- Short-lived access tokens (15-60 minutes)
- Longer-lived refresh tokens (Optional)
- Store tokens securely (HTTP-only cookies)
- Include minimum claims in payload
- Validate tokens on every request
- Implement token revocation mechanism

### Example JWT Payload
```json
{
  "sub": "123e4567-e89b-12d3-a456-426614174000",
  "iat": 1649267898,
  "exp": 1649271498,
  "roles": ["USER"],
  "jti": "unique-token-id"
}
```

## Spring Security Configuration
```kotlin
@Configuration
@EnableWebSecurity
class SecurityConfig(
    private val jwtAuthenticationFilter: JwtAuthenticationFilter
) {
    @Bean
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .csrf { it.disable() }
            .cors { it.configurationSource(corsConfigurationSource()) }
            .sessionManagement { it.sessionCreationPolicy(SessionCreationPolicy.STATELESS) }
            .authorizeHttpRequests { authorize ->
                authorize
                    .requestMatchers("/api/v1/auth/**").permitAll()
                    .requestMatchers(HttpMethod.GET, "/api/v1/posts/**").permitAll()
                    .requestMatchers("/api/v1/**").authenticated()
                    .anyRequest().authenticated()
            }
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter::class.java)
            
        return http.build()
    }
    
    @Bean
    fun corsConfigurationSource(): CorsConfigurationSource {
        val configuration = CorsConfiguration().apply {
            allowedOrigins = listOf("http://localhost:3000")
            allowedMethods = listOf("GET", "POST", "PUT", "DELETE", "OPTIONS")
            allowedHeaders = listOf("Authorization", "Content-Type")
            allowCredentials = true
            maxAge = 3600L
        }
        
        val source = UrlBasedCorsConfigurationSource()
        source.registerCorsConfiguration("/**", configuration)
        return source
    }
    
    @Bean
    fun passwordEncoder(): PasswordEncoder {
        return BCryptPasswordEncoder()
    }
}
```

## Error Handling
- Use global exception handlers
- Return standardized error responses
- Include appropriate HTTP status codes
- Add enough detail for debugging (in development)

### Example Error Response
```json
{
  "status": 400,
  "error": "Bad Request",
  "message": "Username already exists",
  "timestamp": "2025-03-20T12:00:00Z",
  "path": "/api/v1/users",
  "code": "USER_ALREADY_EXISTS"
}
```

## Frontend API Integration
- Use a centralized API client
- Implement authentication token management
- Handle token refresh
- Implement request/response interceptors
- Add proper error handling
- Use environment variables for API URLs

### Example API Client
```typescript
// src/lib/api.ts
import axios from 'axios';

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080/api/v1';

const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor for adding token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor for error handling
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    // Handle token refresh on 401 errors
    // ...
    return Promise.reject(error);
  }
);

export default api;
```

## Security Testing
- Regular security audits
- Vulnerability scanning
- Penetration testing
- Authentication/authorization testing
- Input validation testing 