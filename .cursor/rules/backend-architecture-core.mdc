---
description: バックエンドのクリーンアーキテクチャとDDDの基本原則
globs: ["**/src/main/kotlin/**/*.kt"]
alwaysApply: false
---
# バックエンドのクリーンアーキテクチャとDDDの基本原則

## このルールの要約
- 依存関係は内側から外側への一方通行とする
- ドメインロジックはフレームワークやインフラストラクチャから独立させる
- ドメインはバウンデッドコンテキストに分割する
- 共通言語（ユビキタス言語）を一貫して使用する
- CQRSの原則に従い、読み取りと書き込みの責務を分離する

## クリーンアーキテクチャの原則

クリーンアーキテクチャでは、以下の原則を重視します：

1. **依存関係ルール**: 依存は内側から外側への一方通行のみ
2. **ドメインの独立性**: ドメインロジックはフレームワークやDBから独立
3. **関心事の分離**: 各レイヤーは特定の責任のみを持つ
4. **ドメイン中心**: ビジネスロジックを中心に設計
5. **CQRS**: コマンド（状態変更）とクエリ（情報取得）の責務を分離

## アーキテクチャの層構造

### 1. ドメイン層 (Domain Layer)
- システムの中心
- ビジネスルールとロジックを含む
- エンティティ、値オブジェクト、ドメインサービスを定義
- 外部依存を持たない
- リポジトリインターフェースを定義（実装はアダプター層）

### 2. アプリケーション層 (Application Layer)
- ユースケースを実装
- ドメイン層のオーケストレーション
- トランザクション境界の定義
- 入出力の変換（DTOの取り扱い）
- コマンドユースケースとクエリユースケースの分離

### 3. アダプター層 (Adapters Layer)
- 外部との通信を担当
- コントローラー、リポジトリ実装、外部APIクライアントなど
- ドメインモデルと外部モデルの変換
- クエリサービスの実装（読み取り操作の最適化）

### 4. インフラストラクチャ層 (Infrastructure Layer)
- 技術的な実装の詳細
- データベース、メッセージキュー、外部サービスなど
- 設定クラスやユーティリティ

## パッケージ構造の例

```
com.example
├── domain
│   ├── model
│   │   ├── entity
│   │   ├── valueobject
│   │   └── event
│   ├── repository (interfaces)
│   └── service
├── application
│   ├── usecase
│   │   ├── command   # コマンドユースケース
│   │   └── query     # クエリユースケース
│   ├── dto
│   └── exception
├── adapter
│   ├── controller    # APIコントローラー
│   ├── persistence
│   │   ├── repository # リポジトリ実装
│   │   └── query      # クエリサービス実装
│   └── client        # 外部サービスクライアント
└── infrastructure
    ├── config
    ├── security
    └── util
```

## リポジトリとクエリサービスの役割分担

クリーンアーキテクチャにCQRSを適用する際の責任分担：

### リポジトリ（データの永続化と取得）
- ドメイン層で定義されたインターフェース
- ドメインモデルの永続化と取得を担当
- 集約単位で定義される
- 主に状態変更操作（コマンド）で使用

### クエリサービス（最適化された読み取り操作）
- アダプター層で定義と実装
- 複雑な結合クエリや集計クエリを実行
- パフォーマンスを重視し、DTOを直接返す
- 読み取り専用操作に特化
- 複数の集約をまたいだデータ取得が可能

## バウンデッドコンテキスト

バウンデッドコンテキストはDDDの重要な概念で、以下のような特徴があります：

- ドメインを独立した文脈に分割する
- 各コンテキスト内では一貫した用語と概念を使用
- コンテキスト間の連携は明示的なインターフェースを通じて行う

例えば、以下のようなバウンデッドコンテキストが考えられます：

- ユーザー管理コンテキスト
- ビジネスプロセスコンテキスト
- 決済コンテキスト
- 通知コンテキスト

## ユビキタス言語

ユビキタス言語（共通言語）の重要性：

- ドメイン専門家と開発者の間で共通の言語を構築
- コードやクラス名にもユビキタス言語を使用
- ドメイン用語を一貫して使用することで混乱を防ぐ

## CQRS（コマンド・クエリ責務分離）の適用

CQRSは読み取りと書き込みの操作を分離する原則です：

1. **コマンド（Command）**: システムの状態を変更する操作
   - リポジトリを使用してドメインモデルを操作
   - トランザクション整合性を重視
   - ドメインイベントの発行

2. **クエリ（Query）**: システムから情報を取得する操作
   - クエリサービスを使用して最適化されたデータ取得
   - パフォーマンスを重視
   - DTOを直接返す

### 適用レベル
- **基本レベル**: ユースケースを読み取りと書き込みに分ける
- **中間レベル**: モデルとリポジトリも分離
- **高度レベル**: 読み取りと書き込みのデータストアを完全に分離

### 適用判断基準
- 小規模なシステム: 基本レベルのCQRS適用で十分
- 複雑な検索要件がある: クエリサービスの導入を検討
- 高いスケーラビリティが必要: データストアの分離を検討

## ベストプラクティス

1. **ドメインロジックの集中**: ドメインモデル内にビジネスロジックを集中させる
2. **テスト駆動開発 (TDD)**: モデルと仕様を先に定義し、テストを書いてから実装
3. **技術的詳細からドメインを保護**: ドメイン層が外部依存を持たないようにする
4. **コマンドとクエリの分離**: 読み取りと書き込みの責務を明確に分離する
5. **ユースケース駆動設計**: ユーザーの視点からユースケースを定義し、それを基にモデルを設計 