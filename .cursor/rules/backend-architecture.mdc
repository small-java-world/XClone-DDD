---
description: Kotlin + Spring Bootを使用したバックエンドのクリーンアーキテクチャとDDDの実装ガイドライン
globs: **/*.kt
alwaysApply: false
---
# バックエンドのクリーンアーキテクチャとDDDの実装ガイドライン

## 実装方針

このガイドラインは、AIがKotlin + Spring Bootを使用したバックエンドコードを生成・修正する際の一貫した方針を定義します。以下の原則に従ってください：

1. **抽象度の一貫性**: 同じレイヤー内のコードは同じ抽象度レベルを保つ
2. **命名の一貫性**: 類似したコンポーネントには類似した命名パターンを使用する
3. **責務の明確化**: 各クラスは単一の責務を持ち、その責務を名前に反映させる
4. **インターフェースファースト**: 実装よりもインターフェースを先に設計する
5. **ドメインモデルの純粋性**: ドメインモデルはインフラストラクチャの詳細から独立させる

これらの原則はファイルの詳細な内容よりも優先され、コード生成時や修正時の指針となります。

## 概要

このルールは、Kotlin + Spring Bootを使用したバックエンドにおけるクリーンアーキテクチャとドメイン駆動設計（DDD）の実装ガイドラインを定義します。このガイドラインに従うことで、ビジネスロジックの変更に強く、テスト容易性が高く、長期的なメンテナンス性に優れたシステムを構築できます。

## クリーンアーキテクチャの基本原則

1. **依存関係の方向**: 依存関係は常に内側から外側に向かうようにする（依存性逆転の原則）
2. **レイヤー分離**: 各レイヤーは明確に分離し、適切なインターフェースを通じて通信する
3. **ドメイン中心**: ビジネスロジックをドメイン層に集中させ、技術的詳細から分離する
4. **テスト容易性**: 各レイヤーが疎結合であることで、単体テストを容易にする

## レイヤー構造

クリーンアーキテクチャでは、以下の4つのレイヤーで構成されます：

1. **Entities（ドメイン層）**: ビジネスロジックの中心となるオブジェクト
2. **Use Cases（アプリケーション層）**: アプリケーション固有のビジネスルール
3. **Interface Adapters（アダプター層）**: 外部システムとの連携部分
4. **Frameworks & Drivers（インフラストラクチャ層）**: 技術的詳細を含む最外層

## パッケージ構造

```
com.example.myapp
├── domain            # ドメイン層
│   ├── model         # ドメインモデル（集約ルートごとにパッケージを作成）
│   ├── repository    # リポジトリインターフェース
│   └── service       # ドメインサービス
├── application       # アプリケーション層
│   ├── usecase       # ユースケース（集約ルートごとにパッケージを作成）
│   └── dto           # Data Transfer Objects
├── adapter           # アダプター層
│   ├── persistence   # 永続化アダプター
│   ├── api           # API関連アダプター
│   └── external      # 外部サービスアダプター
└── infrastructure    # インフラストラクチャ層
    ├── config        # 設定関連
    └── security      # セキュリティ関連
```

注: 集約ルートは実際のドメインに合わせて置き換えてください（例：product, order, customerなど）。

## ドメイン層のパターン

### 値オブジェクト（Value Objects）
- 不変で、等価性で比較される
- ファクトリメソッドを使用して生成し、バリデーションを行う
- 例: `EntityId`, `Email`, `Money`

### エンティティ（Entities）
- IDによって識別され、状態を変更できる
- 不変条件をコンストラクタとメソッドで強制する
- ドメインロジックをメソッドとして実装する

### リポジトリインターフェース
- ドメイン層で定義し、集約単位で設計する
- 基本的なCRUD操作を提供する
- 集約のライフサイクルを管理する

## アプリケーション層のパターン

### ユースケース
- 単一の責務を持ち、命名は「動詞+名詞+UseCase」形式
- トランザクション境界を形成する
- 入力はCommandまたはQuery、出力はDTOまたはIDとして定義

## アダプター層のパターン

### コントローラー
- 入力のバリデーションを行い、ユースケースを呼び出す
- 適切なHTTPステータスコードとレスポンスを返す
- 例外をAPIレスポンスに変換する

### リポジトリ実装
- ドメインオブジェクトとデータアクセスオブジェクトの変換を担当
- インフラストラクチャの詳細（SQL、ORMなど）を隠蔽する

## インフラストラクチャ層のパターン

### 設定クラス
- Spring Bootの設定を担当
- セキュリティ、データベース、キャッシュなどの設定を行う

## アンチパターン

以下のようなアンチパターンは避けてください：

1. **レイヤー間の直接依存**: 外側のレイヤーから内側のレイヤーに直接依存しない
2. **プレゼンテーションロジックの混在**: ビジネスロジックとプレゼンテーションロジックを混在させない
3. **ドメインオブジェクトの公開**: ドメインオブジェクトをAPIレスポンスとして直接公開しない
4. **アノーテーション汚染**: ドメインモデルに永続化アノーテーションを付与しない
5. **単一責務の原則違反**: クラスやメソッドが複数の責務を持たないようにする

## まとめ

クリーンアーキテクチャとDDDを組み合わせることで、ビジネスロジックを中心とした保守性の高いコードベースを実現できます。各レイヤーの責務を明確にし、依存関係の方向を適切に管理することが重要です。 