---
description: UUIDの使用とデータベースでの最適化
globs: ["**/src/main/kotlin/**/domain/model/**/*Id.kt", "**/src/main/kotlin/**/infrastructure/util/UuidUtil.kt"]
alwaysApply: false
---
# UUIDの使用とデータベースでの最適化

## UUIDの最適化

データベースパフォーマンスを考慮し、UUIDをBINARY(16)として保存する方式を採用します。

### バイナリUUID変換ユーティリティ

```kotlin
// UUIDをバイナリに変換するユーティリティ
object UuidUtil {
    fun uuidToBinary(uuid: UUID): ByteArray {
        val buffer = ByteBuffer.wrap(ByteArray(16))
        buffer.putLong(uuid.mostSignificantBits)
        buffer.putLong(uuid.leastSignificantBits)
        return buffer.array()
    }
    
    fun binaryToUuid(bytes: ByteArray): UUID {
        val buffer = ByteBuffer.wrap(bytes)
        val high = buffer.getLong()
        val low = buffer.getLong()
        return UUID(high, low)
    }
}
```

### MySQL DDL例

```sql
CREATE TABLE entities (
    id BINARY(16) PRIMARY KEY,
    attribute VARCHAR(100) NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    status VARCHAR(20) NOT NULL
);
```

### JDBCでの扱い方

```kotlin
// JDBC PreparedStatementでの設定
preparedStatement.setBytes(1, uuidToBinary(entity.id.value))

// ResultSetからの取得
val id = binaryToUuid(resultSet.getBytes("id"))
```

### jOOQでの扱い方

```kotlin
// jOOQ INSERT
dslContext.insertInto(ENTITY_TABLE)
    .set(ENTITY_TABLE.ID, uuidToBinary(entity.id.value))
    .set(ENTITY_TABLE.NAME, entity.name.value)
    // 他のフィールド...
    .execute()

// jOOQ SELECT
dslContext.selectFrom(ENTITY_TABLE)
    .where(ENTITY_TABLE.ID.eq(uuidToBinary(id.value)))
    .fetchOne()
    ?.let { record ->
        val entityId = binaryToUuid(record.get(ENTITY_TABLE.ID))
        // エンティティの再構築...
    }
```

## ID値オブジェクトの実装

エンティティIDは値オブジェクトとして実装し、型安全性を確保します。

```kotlin
@JvmInline
value class EntityId private constructor(val value: UUID) {
    companion object {
        fun from(value: String): EntityId {
            return try {
                EntityId(UUID.fromString(value))
            } catch (e: IllegalArgumentException) {
                throw IllegalArgumentException("不正なID形式です: $value", e)
            }
        }
        
        fun from(value: UUID): EntityId {
            return EntityId(value)
        }
        
        fun generate(): EntityId {
            return EntityId(UUID.randomUUID())
        }
    }
    
    override fun toString(): String = value.toString()
}
```

## 時系列UUIDの使用

タイムスタンプベースのUUIDを使用することで、インデックス効率を向上させることができます。

```kotlin
object TimeBasedUuidGenerator {
    private val NODE_ID = randomNodeId()
    private val clock = Clockseq()
    
    fun generate(): UUID {
        val timeMillis = System.currentTimeMillis()
        val clockSeq = clock.nextVal()
        return generateUUID(timeMillis, clockSeq, NODE_ID)
    }
    
    private fun generateUUID(timeMillis: Long, clockSeq: Int, node: ByteArray): UUID {
        val msb = ((timeMillis & 0xFFFFFFFFL) << 32) or
                 ((timeMillis & 0xFFFF00000000L) shr 16) or
                 0x1000 or
                 ((timeMillis & 0xFFF000000000000L) shr 48)
        
        val lsb = (clockSeq.toLong() << 48) or node.let {
            var nodeVal = 0L
            for (i in 0..5) {
                nodeVal = (nodeVal << 8) | (it[i].toLong() and 0xFF)
            }
            nodeVal
        }
        
        return UUID(msb, lsb)
    }
    
    private fun randomNodeId(): ByteArray {
        val rnd = Random()
        val nodeId = ByteArray(6)
        rnd.nextBytes(nodeId)
        nodeId[0] = (nodeId[0].toInt() or 0x01).toByte() // マルチキャストビットを設定
        return nodeId
    }
    
    private class Clockseq {
        @Volatile
        private var sequence = Random().nextInt(0xFFFF)
        
        fun nextVal(): Int {
            return sequence++ and 0x3FFF // 14ビットに制限
        }
    }
}
```

## まとめ

- UUIDはBINARY(16)として保存することでストレージを最適化
- タイムスタンプベースのUUIDを使用してインデックス効率を向上
- 値オブジェクトとしてID型を実装し型安全性を確保
- UUIDの変換ユーティリティを用意して一貫した処理を実現 