# AIにルール生成してもらった結果はこうなりました

プロジェクトの効率化のため、Cursor AIにプロジェクトルールを生成してもらいました。以下が各ルールファイルとその内容です。

## ルールファイル: `.cursor/rules/200-frontend-nextjs.mdc`

```yaml
---
description: Next.jsとReactのフロントエンド開発ベストプラクティス
globs: ["app/**/*.{tsx,jsx,ts,js}", "components/**/*.{tsx,jsx,ts,js}"]
tags: ["frontend", "nextjs", "react"]
priority: 200
version: 1.0.0
---

# Next.jsとReactのフロントエンド開発ベストプラクティス

## コンポーネント設計
- コンポーネントは単一責任の原則に従って設計する
- Presentational ComponentsとContainer Componentsを分離する
- 再利用可能なコンポーネントは`components/common`ディレクトリに配置する
- ページ固有のコンポーネントは対応するページディレクトリに配置する

## データフェッチング
- サーバーコンポーネントではfetchを直接使用する
- クライアントコンポーネントではSWRまたはReact Queryを使用する
- APIルートは`app/api`ディレクトリに配置する

## パフォーマンス最適化
- 適切な場所でコンポーネントをメモ化する(`React.memo`, `useMemo`, `useCallback`)
- 画像には必ず`next/image`コンポーネントを使用する
- 動的インポートと遅延ロードを活用する

## 型安全性
- すべてのコンポーネントpropsに適切な型を定義する
- APIレスポンスには明示的な型を定義する
- any型の使用を避ける
```

## ルールファイル: `.cursor/rules/300-testing.mdc`

```yaml
---
description: バックエンドとフロントエンドのテストのベストプラクティス
globs: ["**/*.test.{ts,js,tsx,jsx}", "**/*.spec.{ts,js,tsx,jsx}", "src/test/**/*"]
tags: ["testing", "quality"]
priority: 300
version: 1.0.0
---

# テストのベストプラクティス

## テスト構造
- テストファイルは対象のファイルと同じディレクトリに配置する
- テストファイルの命名規則は`[ファイル名].test.[拡張子]`または`[ファイル名].spec.[拡張子]`とする
- テストケースはBDD形式で記述する（describe, it, expect）

## フロントエンドテスト
- コンポーネントテストにはReact Testing Libraryを使用する
- スナップショットテストは必要最小限に留める
- E2EテストにはPlaywrightを使用する

## バックエンドテスト
- ユニットテストとインテグレーションテストを分離する
- APIテストは実際のリクエスト/レスポンスサイクルをシミュレートする
- モックとスタブは適切に使用する

## テストカバレッジ
- コアビジネスロジックは80%以上のカバレッジを目指す
- テスト実行時にカバレッジレポートを生成する
- CIパイプラインでテストカバレッジチェックを実施する
```

## ルールファイル: `.cursor/rules/400-development-environment.mdc`

```yaml
---
description: 開発環境とDockerセットアップのベストプラクティス
globs: ["Dockerfile*", "docker-compose*.yml", ".env*", "*.config.js", "package.json"]
tags: ["devops", "environment"]
priority: 400
version: 1.0.0
---

# 開発環境とDockerセットアップのベストプラクティス

## Docker構成
- マルチステージビルドを活用してイメージサイズを最小化する
- 本番用と開発用のDockerfileを分離する
- 環境変数は`.env`ファイルで管理し、機密情報は`.env.example`に記載しない
- コンテナ間の依存関係は`depends_on`で明示する

## パッケージ管理
- package.jsonでは明確なバージョン指定を使用する
- 開発依存関係と本番依存関係を適切に分離する
- npm scriptsでよく使うコマンドをエイリアス化する

## 環境変数
- アプリケーション設定は環境変数で制御する
- 環境変数のスキーマバリデーションを実装する
- 機密情報は適切にシークレット管理する

## CI/CD
- GitHubActionsでCI/CDパイプラインを構築する
- ビルド、テスト、デプロイの各ステップを自動化する
- 本番デプロイ前に必ずステージング環境でテストする
```

## ルールファイル: `.cursor/rules/500-database-migrations.mdc`

```yaml
---
description: データベース管理とFlywayマイグレーションのベストプラクティス
globs: ["src/main/resources/db/migration/**/*.sql", "build.gradle", "gradle/**/*"]
tags: ["database", "flyway", "migrations"]
priority: 500
version: 1.0.0
---

# データベース管理とFlywayマイグレーションのベストプラクティス

## マイグレーションファイル命名規則
- マイグレーションファイルは`V[バージョン]__[説明].sql`という形式で命名する
- バージョンは連番とし、桁数を揃える（例：V001, V002）
- 説明は単語をアンダースコアで連結し、何をするマイグレーションかを明確にする

## マイグレーションスクリプト作成ルール
- 各マイグレーションは冪等性を保証する
- 1つのマイグレーションファイルに1つの論理的変更のみ含める
- テーブル作成時は必ず主キーを定義する
- カラム定義には適切なデータ型と制約を設定する

## Flyway設定
- baselineバージョンを明示的に設定する
- マイグレーション失敗時の対応方針を定める
- 本番環境では検証後にのみマイグレーションを実行する

## データベースバージョン管理
- スキーマの変更履歴を文書化する
- 大規模なスキーマ変更は複数のマイグレーションに分割する
- ロールバック戦略を事前に計画する
```

これらのルールを導入することで、プロジェクトのコード品質と一貫性が大幅に向上しました。チームメンバー全員が同じガイドラインに従うことで、開発効率も高まっています。 